/**
* Copyright © 2011 Mathparca Ltd. All rights reserved.
*/

package com.mathpar.Graphic3D;

/**
 *
 * <p>Класс предназначен для установки освещения сцены. </p>
 * <p> Существует возможность
 * устанавливать  источник света,задавать интенсивность источника света.
 * Поскольку коэффициент диффузного отражения света зависит от материала и длины волны,
 * для простоты расчета считается постоянным-выбирается константой [0..1].
 * Поскольку для расчета освещения сцены распределенным источником света требуются большие вычислительные затраты,
 * то в данной работе будет рассматриваться точечный тип источника света, а соответственно коэффициент рассеянного света
 * возможно выбирать константой.
 * Для зеркального отражения света задаются такие параметры как коэффициент отражения,зависящий от свойств поверхности освещаемого
 * объекта  и степень n косинуса угла между вектором отражения света и вектором наблюдения.Большие значения n дают
 * сфокусированные пространственные распределения характеристик металлов и других блестящих поверхностей</p>
 *
 */
public class GM_Light {

    double lightDistance;
    /**
     * массив,содержащий положение каждого из источников света
     */
    public GM_Vector lights;
    /**
     *  интенсивность источника света
     */
    public double Jl = 0.9f;
    /**
     *содержит интенсивность рассеянного света
     */
    private double Ja = 0.7f;
    /**
     * степень,аппроксимирующая пространственное распределение зеркально отраженного света
     */
    private int n = 1;
    /**
     * кривая отражения представляющая отношение зеркально отраженного света
     * к падающему(выбирается константой из эстетических соображений (в силу своей сложности))
     */
    private double Ks = 0.1;
    /**
     * коэффициент диффузного отражения  рассеянного света выбирается из отрезка [0,1]
     */
    private double Ka = 0.6f;
    /**
     * коэффициент диффузного отражения света выбирается из отрезка [0,1]
     */
    private double Kd = 0.6f;
    GM_Vector viewer;

    /**
     * конструктор класса отвечает за задание всех атрибутов освещения
     */
    public GM_Light(GM_Vector light, GM_Vector viewer) {
        this.lights = light;
        this.viewer = viewer;

    }

    /**
     * метод находит коэффициент интенсивности отраженного света от плоскости,используя функцию закраски:
     * <p>J = Ja*Ka + Jl*(Kd*cosnk+ Ks*cosRS^n), где<p> cosnk-косинус угла между вектором  света и вектором
     * нормали к плоскости,</p><p>cosRS-косинус угла между вектором отражения света и вектором наблюдения</p>
     *</p>
     * @param p0 GM_Vector-вершины треугольника
     * @param p1 GM_Vector
     * @param p2 GM_Vector
     * @param viewer GM_Vector- положение наблюдателя
     * @return double
     */
    public double Light(GM_Vector p0, GM_Vector p1, GM_Vector p2) {
        double K = 0.5;

        double cosRS, cosnk0, cosnk1, cosnk2,Jo;
        //вектор отражения света от объекта
        GM_Vector R = lights;
        //косинус угла между вектором отражения и  вектором наблюдателя
        cosRS = ((R.x * viewer.x + R.y * viewer.y + R.z * viewer.z) / (R.getLength() * viewer.getLength()));

        //вычисляем косинус угла между радиус-вектором точки и вектором падения света
        if (p0.getLength() == 0) {
            cosnk0 = 0;
        } else {
            cosnk0 = ((p0.x * lights.x + p0.y * lights.y + p0.z * lights.z)
                    / (p0.getLength() * lights.getLength()));
        }
        if (p1.getLength() == 0) {
            cosnk1 = 0;
        } else {
            cosnk1 = ((p1.x * lights.x + p1.y * lights.y + p1.z * lights.z)
                    / (p1.getLength() * lights.getLength()));
        }
        if (p2.getLength() == 0) {
            cosnk2 = 0;
        } else {
            cosnk2 = ((p2.x * lights.x + p2.y * lights.y + p2.z * lights.z)
                    / (p2.getLength() * lights.getLength()));
        }
        Jo = (Ja * Ka +Jl * (Kd * (cosnk0 + cosnk1 + cosnk2) / 3 + Ks * Math.pow(cosRS, n)));

        return Jo;
    }
}
